package com.github.tymefly.eel.function.util;

import javax.annotation.Nonnull;

import com.github.tymefly.eel.udf.DefaultArgument;
import com.github.tymefly.eel.udf.EelFunction;
import com.github.tymefly.eel.udf.PackagedEelFunction;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * These are the EEL Functions that support logging. This could be used by the client
 * to help debug problematic expressions or monitor the values generated by an expression. For example the
 * EEL expression:
 * <br>
 * <pre> "${ Log.debug(1 + 2 + 3) }"</pre>
 * will calculate the value {@literal 6}, log it at debug level, and then return it as
 * {@link com.github.tymefly.eel.Type#TEXT} to the client application.
 * <br>
 * Logging hardcoded values probably isn't that valuable, however EEL can log values read from the symbols table.
 * For example:
 * <br>
 * <pre> "Hello: $( Log.info( ${userName} ))"</pre>
 * will read a value from the symbols table, log it and then used it as part of a friendly message.
 * <br>
 * EEL also supports conditional logging. For example:
 * <br>
 * <pre>"The Result is: ${key-$( log.info("defaulting to {}", "defaultValue") )}"</pre>
 *
 * In this case if {@literal key} is in the symbols table then its associated value will be returned (without any
 * logging). However, if the value can not be read then a warning is logged and the {@literal defaultValue} is
 * returned instead. This works because the default value for a variable is a complete EEL expression in its own right,
 * as such it can support embedded expressions that include function calls
 * <p>
 * <b>NOTE:</b> As expressions can be set after applications have been developed and deployed then there is a
 * need to guard against log repudiation attacks. Consequently:
 * <ul>
 *  <li>All logged messages are prefixed by the literal text "{@code Logged EEL Message: }" to make it obvious
 *      they are generated by EEL and not from some other source</li>
 *  <li>Control characters are filtered out of the logged message. It should be difficult to pass them to a
 *      logging (EEL doesn't accept them as input, numbers are converted to their text representation rather than
 *      unicode characters), but EEL can't guarantee what imported functions will do</li>
 * </ul>
 * <p>
 * <b>IMPORTANT NOTE:</b> The clients logging framework is responsible for enabling logging.
 * EEL writes all its messages to the {@literal com.github.tymefly.eel.log} logger, so it is recommended that this
 * is configured with {@link org.slf4j.Logger#trace(String)} level logging enabled.
 */
@PackagedEelFunction
public class EelLogger {
    /** The name of the logger used by EEL to log data */
    public static final String EEL_LOGGER = "com.github.tymefly.eel.log";

    private static final Logger LOGGER = LoggerFactory.getLogger(EEL_LOGGER);
    private static final String PREFIX = "Logged EEL Message: ";


    /**
     * Entry point for the {@code log.error} function which will write a message to the logger at
     * the ERROR level.
     * The EEL syntax for this function is:
     * <ul>
     *   <li><code>Log.error( value )</code> - write a value to the logger</li>
     *   <li><code>Log.error( format, value... )</code> - write a formatted message to the logger</li>
     * </ul>
     * @param first     Either the value to be logged or the formatting string
     * @param others    arguments for logging
     * @return the last {@code value} logged
     */
    @EelFunction(name = "log.error")
    public String error(@Nonnull String first,
                        @DefaultArgument(of = "") String... others) {
        int length = others.length;
        String result;

        first = sanitise(first);

        if (length == 0) {
            result = first;

            LOGGER.error(PREFIX + result);
        } else {
            String[] arguments = sanitise(others);
            result = arguments[length - 1];

            LOGGER.error(PREFIX + first, (Object[]) arguments);
        }

        return result;
    }

    /**
     * Entry point for the {@code log.warn} function which will write a message to the logger at
     * the WARN level.
     * <br>
     * The EEL syntax for this function is:
     * <ul>
     *   <li><code>Log.warn( value )</code> - write a value to the logger</li>
     *   <li><code>Log.warn( format, value... )</code> - write a formatted message to the logger</li>
     * </ul>
     * @param first     Either the value to be logged or the formatting string
     * @param others    arguments for logging
     * @return the last {@code value} logged
     */
    @EelFunction(name = "log.warn")
    public String warn(@Nonnull String first,
                       @DefaultArgument(of = "") String... others) {
        int length = others.length;
        String result;

        first = sanitise(first);

        if (length == 0) {
            result = first;

            LOGGER.warn(PREFIX + first);
        } else {
            String[] arguments = sanitise(others);
            result = arguments[length - 1];

            LOGGER.warn(PREFIX + first, (Object[]) arguments);
        }

        return result;
    }

    /**
     * Entry point for the {@code log.info} function which will write a message to the logger at
     * the INFO level.
     * <br>
     * The EEL syntax for this function is:
     * <ul>
     *   <li><code>Log.info( value )</code> - write a value to the logger</li>
     *   <li><code>Log.info( format, value... )</code> - write a formatted message to the logger</li>
     * </ul>
     * @param first     Either the value to be logged or the formatting string
     * @param others    arguments for logging
     * @return the last {@code value} logged
     */
    @EelFunction(name = "log.info")
    public String info(@Nonnull String first,
                       @DefaultArgument(of = "") String... others) {
        int length = others.length;
        String result;

        first = sanitise(first);

        if (length == 0) {
            result = first;

            LOGGER.info(PREFIX + first);
        } else {
            String[] arguments = sanitise(others);
            result = arguments[length - 1];

            LOGGER.info(PREFIX + first, (Object[]) arguments);
        }

        return result;
    }


    /**
     * Entry point for the {@code log.debug} function which will write a message to the logger at
     * the DEBUG level.
     * <br>
     * The EEL syntax for this function is:
     * <ul>
     *   <li><code>Log.debug( value )</code> - write a value to the logger</li>
     *   <li><code>Log.debug( format, value... )</code> - write a formatted message to the logger</li>
     * </ul>
     * @param first     Either the value to be logged or the formatting string
     * @param others    arguments for logging
     * @return the last {@code value} logged
     */
    @EelFunction(name = "log.debug")
    public String debug(@Nonnull String first,
                        @DefaultArgument(of = "") String... others) {
        int length = others.length;
        String result;

        first = sanitise(first);

        if (length == 0) {
            result = first;

            LOGGER.debug(PREFIX + first);
        } else {
            String[] arguments = sanitise(others);
            result = arguments[length - 1];

            LOGGER.debug(PREFIX + first, (Object[]) arguments);
        }

        return result;
    }


    /**
     * Entry point for the {@code log.trace} function which will write a message to the logger at
     * the TRACE level.
     * <br>
     * The EEL syntax for this function is:
     * <ul>
     *   <li><code>Log.trace( value )</code> - write a value to the logger</li>
     *   <li><code>Log.trace( format, value... )</code> - write a formatted message to the logger</li>
     * </ul>
     * @param first     Either the value to be logged or the formatting string
     * @param others    arguments for logging
     * @return the last {@code value} logged
     */
    @EelFunction(name = "log.trace")
    public String trace(@Nonnull String first,
                        @DefaultArgument(of = "") String... others) {
        int length = others.length;
        String result;

        first = sanitise(first);

        if (length == 0) {
            result = first;

            LOGGER.trace(PREFIX + first);
        } else {
            String[] arguments = sanitise(others);
            result = arguments[length - 1];

            LOGGER.trace(PREFIX + first, (Object[]) arguments);
        }

        return result;
    }


    @Nonnull
    private String[] sanitise(@Nonnull String[] arguments) {
        for (int index = 0; index != arguments.length; index++) {
            arguments[index] = sanitise(arguments[index]);
        }

        return arguments;
    }

    @Nonnull
    private String sanitise(@Nonnull String value) {
        return value.replaceAll("[^\\p{Print}\\t]", "");
    }
}
